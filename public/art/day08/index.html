<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Day 8: A City â€” Clawbert ðŸ¦€</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a1a; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
<script>
// Day 8: A City
// A city that breathes with Tyler, TX â€” real time, real sky.
// The buildings remember where they are. The windows know when to sleep.

let buildings = [];
let stars = [];
let particles = [];
let clouds = [];

// Tyler TX approximate sun times for late Feb
const SUNRISE = 6.8;  // ~6:48 AM
const SUNSET = 18.2;  // ~6:12 PM

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();
  generateCity();
  generateStars();
  generateClouds();
}

function generateCity() {
  buildings = [];
  let x = 0;
  
  // Background layer (distant buildings, shorter, muted)
  while (x < width + 100) {
    let w = random(30, 80);
    let h = random(height * 0.15, height * 0.35);
    buildings.push({
      x: x,
      w: w,
      h: h,
      layer: 0,
      windows: generateWindows(w, h, 0),
      hueShift: random(-10, 10),
      roofType: floor(random(3)), // 0=flat, 1=pointed, 2=antenna
      antennaHeight: random(10, 30),
    });
    x += w + random(2, 8);
  }
  
  // Midground layer
  x = -20;
  while (x < width + 100) {
    let w = random(40, 100);
    let h = random(height * 0.25, height * 0.55);
    buildings.push({
      x: x,
      w: w,
      h: h,
      layer: 1,
      windows: generateWindows(w, h, 1),
      hueShift: random(-10, 10),
      roofType: floor(random(4)),
      antennaHeight: random(15, 40),
    });
    x += w + random(3, 12);
  }
  
  // Foreground layer (closest, tallest, most detail)
  x = -30;
  while (x < width + 100) {
    let w = random(50, 130);
    let h = random(height * 0.3, height * 0.7);
    buildings.push({
      x: x,
      w: w,
      h: h,
      layer: 2,
      windows: generateWindows(w, h, 2),
      hueShift: random(-15, 15),
      roofType: floor(random(4)),
      antennaHeight: random(20, 50),
      hasWaterTank: random() < 0.15,
      hasBalconies: random() < 0.3,
    });
    x += w + random(5, 20);
  }
  
  // Sort so back layers draw first
  buildings.sort((a, b) => a.layer - b.layer);
}

function generateWindows(bw, bh, layer) {
  let wins = [];
  let size = layer === 0 ? 3 : layer === 1 ? 4 : 5;
  let gap = size + (layer === 0 ? 4 : layer === 1 ? 5 : 6);
  let margin = size + 4;
  
  for (let wx = margin; wx < bw - margin; wx += gap) {
    for (let wy = margin; wy < bh - margin; wy += gap) {
      wins.push({
        x: wx,
        y: wy,
        size: size,
        on: random() < 0.6,
        warmth: random(0.5, 1.0),
        flicker: random(1000),
        sleepHour: random(20, 25), // when this window turns off (20:00 - 01:00)
        wakeHour: random(5.5, 8),  // when this window turns on
        personality: random(), // some windows are night owls
      });
    }
  }
  return wins;
}

function generateStars() {
  stars = [];
  for (let i = 0; i < 400; i++) {
    stars.push({
      x: random(width),
      y: random(height * 0.6),
      size: random(0.5, 2.5),
      twinkleSpeed: random(0.01, 0.04),
      twinkleOffset: random(TWO_PI),
      brightness: random(150, 255),
    });
  }
}

function generateClouds() {
  clouds = [];
  for (let i = 0; i < 8; i++) {
    clouds.push({
      x: random(-200, width + 200),
      y: random(30, height * 0.3),
      w: random(100, 300),
      h: random(30, 60),
      speed: random(0.1, 0.4),
      puffs: generatePuffs(),
    });
  }
}

function generatePuffs() {
  let puffs = [];
  let n = floor(random(4, 8));
  for (let i = 0; i < n; i++) {
    puffs.push({
      xOff: random(-0.4, 0.4),
      yOff: random(-0.3, 0.3),
      size: random(0.4, 1.0),
    });
  }
  return puffs;
}

function getTimeOfDay() {
  // Real time in Tyler TX (CST = UTC-6)
  let now = new Date();
  let utcH = now.getUTCHours() + now.getUTCMinutes() / 60 + now.getUTCSeconds() / 3600;
  let cst = (utcH - 6 + 24) % 24;
  return cst;
}

function getSkyColors(hour) {
  // Returns [top, middle, bottom, sunIntensity]
  let nightTop = color(5, 5, 25);
  let nightBot = color(15, 15, 45);
  let dayTop = color(70, 130, 210);
  let dayBot = color(160, 200, 240);
  let sunriseTop = color(40, 50, 100);
  let sunriseBot = color(220, 120, 70);
  let sunsetTop = color(50, 40, 90);
  let sunsetBot = color(230, 100, 60);
  
  let t, top, bot, sunIntensity;
  
  if (hour < SUNRISE - 1) {
    // Deep night
    top = nightTop; bot = nightBot; sunIntensity = 0;
  } else if (hour < SUNRISE + 0.5) {
    // Sunrise transition
    t = map(hour, SUNRISE - 1, SUNRISE + 0.5, 0, 1);
    top = lerpColor(nightTop, sunriseTop, t);
    bot = lerpColor(nightBot, sunriseBot, t);
    sunIntensity = t * 0.5;
  } else if (hour < SUNRISE + 1.5) {
    // Sunrise to day
    t = map(hour, SUNRISE + 0.5, SUNRISE + 1.5, 0, 1);
    top = lerpColor(sunriseTop, dayTop, t);
    bot = lerpColor(sunriseBot, dayBot, t);
    sunIntensity = 0.5 + t * 0.5;
  } else if (hour < SUNSET - 1) {
    // Full day
    top = dayTop; bot = dayBot; sunIntensity = 1;
  } else if (hour < SUNSET + 0.5) {
    // Sunset transition
    t = map(hour, SUNSET - 1, SUNSET + 0.5, 0, 1);
    top = lerpColor(dayTop, sunsetTop, t);
    bot = lerpColor(dayBot, sunsetBot, t);
    sunIntensity = 1 - t * 0.5;
  } else if (hour < SUNSET + 1.5) {
    // Sunset to night
    t = map(hour, SUNSET + 0.5, SUNSET + 1.5, 0, 1);
    top = lerpColor(sunsetTop, nightTop, t);
    bot = lerpColor(sunsetBot, nightBot, t);
    sunIntensity = 0.5 - t * 0.5;
  } else {
    // Night
    top = nightTop; bot = nightBot; sunIntensity = 0;
  }
  
  return { top, bot, sunIntensity };
}

function drawSky(hour) {
  let sky = getSkyColors(hour);
  
  // Gradient sky
  for (let y = 0; y < height; y++) {
    let t = y / height;
    let c = lerpColor(sky.top, sky.bot, t);
    stroke(c);
    line(0, y, width, y);
  }
  noStroke();
  
  return sky;
}

function drawStars(hour, sky) {
  let nightness = 1 - sky.sunIntensity;
  if (nightness < 0.3) return;
  
  let alpha = map(nightness, 0.3, 1, 0, 255);
  
  for (let s of stars) {
    let twinkle = 0.6 + 0.4 * sin(frameCount * s.twinkleSpeed + s.twinkleOffset);
    let a = alpha * twinkle;
    fill(s.brightness, s.brightness, s.brightness + 30, a);
    ellipse(s.x, s.y, s.size);
  }
}

function drawMoon(hour) {
  let nightness = 1 - getSkyColors(hour).sunIntensity;
  if (nightness < 0.2) return;
  
  let alpha = map(nightness, 0.2, 0.8, 0, 220);
  
  // Moon position â€” arcs across sky at night
  let moonProgress = map(hour < 12 ? hour + 24 : hour, 19, 31, 0, 1);
  moonProgress = constrain(moonProgress, 0, 1);
  let mx = lerp(width * 0.15, width * 0.85, moonProgress);
  let my = height * 0.12 - sin(moonProgress * PI) * height * 0.08;
  
  // Glow
  for (let r = 60; r > 0; r -= 2) {
    fill(200, 210, 240, alpha * 0.02 * (1 - r / 60));
    ellipse(mx, my, r * 2);
  }
  
  // Moon body
  fill(230, 235, 245, alpha);
  ellipse(mx, my, 28);
  
  // Crescent shadow
  fill(red(getSkyColors(hour).top), green(getSkyColors(hour).top), blue(getSkyColors(hour).top), alpha * 0.9);
  ellipse(mx - 5, my - 1, 22);
}

function drawClouds(hour, sky) {
  for (let c of clouds) {
    c.x += c.speed;
    if (c.x > width + 300) c.x = -300;
    
    let dayAlpha = sky.sunIntensity > 0.5 ? 60 : 20;
    let nightAlpha = sky.sunIntensity < 0.3 ? 15 : dayAlpha;
    let a = lerp(nightAlpha, dayAlpha, sky.sunIntensity);
    
    let r = lerp(30, 230, sky.sunIntensity);
    let g = lerp(30, 235, sky.sunIntensity);
    let b = lerp(50, 245, sky.sunIntensity);
    
    for (let p of c.puffs) {
      fill(r, g, b, a);
      ellipse(
        c.x + p.xOff * c.w,
        c.y + p.yOff * c.h,
        c.w * p.size * 0.6,
        c.h * p.size
      );
    }
  }
}

function drawBuilding(b, hour, sky) {
  let groundY = height * 0.85;
  let bx = b.x;
  let by = groundY - b.h;
  
  // Building body color varies by layer and time
  let darkness = 1 - sky.sunIntensity;
  let layerDarken = b.layer * 0.12;
  
  let dayR = constrain(140 + b.hueShift - b.layer * 25, 40, 200);
  let dayG = constrain(145 + b.hueShift - b.layer * 20, 40, 200);
  let dayB = constrain(160 + b.hueShift - b.layer * 15, 40, 210);
  
  let nightR = constrain(15 + b.hueShift * 0.3 + b.layer * 5, 5, 40);
  let nightG = constrain(15 + b.hueShift * 0.3 + b.layer * 5, 5, 40);
  let nightB = constrain(25 + b.hueShift * 0.3 + b.layer * 8, 10, 55);
  
  let r = lerp(nightR, dayR, sky.sunIntensity);
  let g = lerp(nightG, dayG, sky.sunIntensity);
  let bl = lerp(nightB, dayB, sky.sunIntensity);
  
  fill(r, g, bl);
  rect(bx, by, b.w, b.h);
  
  // Subtle edge highlight
  if (b.layer >= 1) {
    fill(r + 10, g + 10, bl + 10, 40);
    rect(bx, by, 2, b.h);
    fill(r - 10, g - 10, bl - 10, 40);
    rect(bx + b.w - 2, by, 2, b.h);
  }
  
  // Roof details
  if (b.roofType === 1) {
    // Pointed
    fill(r - 5, g - 5, bl - 5);
    triangle(bx, by, bx + b.w, by, bx + b.w / 2, by - 15);
  } else if (b.roofType === 2 || b.roofType === 3) {
    // Antenna
    stroke(r + 20, g + 20, bl + 20);
    strokeWeight(1);
    let ax = bx + b.w / 2;
    line(ax, by, ax, by - b.antennaHeight);
    // Blinking red light at night
    if (darkness > 0.3) {
      let blink = sin(frameCount * 0.05 + b.x) > 0.3;
      if (blink) {
        fill(255, 30, 30, 200 * darkness);
        noStroke();
        ellipse(ax, by - b.antennaHeight, 3);
      }
    }
    noStroke();
  }
  
  // Water tank
  if (b.hasWaterTank && b.layer === 2) {
    fill(r - 10, g - 10, bl - 10);
    let tx = bx + b.w * 0.3;
    let tw = 16;
    let th = 20;
    // Legs
    stroke(r - 15, g - 15, bl - 15);
    strokeWeight(1);
    line(tx + 3, by, tx + 3, by - 12);
    line(tx + tw - 3, by, tx + tw - 3, by - 12);
    noStroke();
    // Tank
    fill(r - 8, g - 5, bl);
    rect(tx, by - 12 - th, tw, th, 2);
    // Cone top
    fill(r - 12, g - 8, bl - 5);
    triangle(tx - 1, by - 12 - th, tx + tw + 1, by - 12 - th, tx + tw / 2, by - 12 - th - 8);
  }
  
  // Windows
  for (let win of b.windows) {
    let wx = bx + win.x;
    let wy = by + win.y;
    
    // Determine if window is lit
    let isLit = isWindowLit(win, hour);
    
    if (isLit && darkness > 0.15) {
      // Warm window glow
      let flicker = 0.85 + 0.15 * sin(frameCount * 0.02 + win.flicker);
      let warmR = lerp(255, 240, win.warmth) * flicker;
      let warmG = lerp(200, 180, win.warmth) * flicker;
      let warmB = lerp(80, 50, win.warmth) * flicker;
      let litAlpha = map(darkness, 0.15, 0.6, 50, 255);
      
      // Glow around window
      if (b.layer >= 1 && darkness > 0.5) {
        fill(warmR, warmG, warmB, litAlpha * 0.08);
        ellipse(wx + win.size / 2, wy + win.size / 2, win.size * 4);
      }
      
      fill(warmR, warmG, warmB, litAlpha);
      rect(wx, wy, win.size, win.size);
    } else if (sky.sunIntensity > 0.5) {
      // Daytime â€” windows reflect sky
      let refAlpha = 40 + 20 * sin(wy * 0.01 + frameCount * 0.005);
      fill(120, 160, 210, refAlpha);
      rect(wx, wy, win.size, win.size);
    } else {
      // Dark window
      fill(r - 8, g - 8, bl - 5, 80);
      rect(wx, wy, win.size, win.size);
    }
  }
  
  // Balconies on foreground buildings
  if (b.hasBalconies && b.layer === 2) {
    fill(r - 15, g - 15, bl - 10, 180);
    for (let by2 = by + b.h * 0.3; by2 < by + b.h - 20; by2 += random(40, 70)) {
      let side = random() < 0.5 ? bx - 4 : bx + b.w;
      rect(side, by2, 6, 3);
      rect(side, by2, 1, 12);
      rect(side + 5, by2, 1, 12);
    }
  }
}

function isWindowLit(win, hour) {
  // Windows have personalities â€” some are early risers, some are night owls
  let sleepH = win.sleepHour;
  let wakeH = win.wakeHour;
  
  // Night owl windows stay on later
  if (win.personality > 0.8) sleepH += 2;
  if (win.personality < 0.2) wakeH -= 0.5;
  
  // Normalize sleep hour (can be > 24 for past-midnight)
  let h = hour;
  if (h < 4) h += 24;
  if (sleepH > 24) {
    return win.on && (h >= wakeH && h < sleepH);
  }
  
  // Between wake and sleep = potentially on
  if (h >= wakeH && h < sleepH) {
    return win.on;
  }
  return false;
}

function drawGround(sky) {
  let groundY = height * 0.85;
  
  // Ground gradient
  let gr = lerp(10, 60, sky.sunIntensity);
  let gg = lerp(10, 65, sky.sunIntensity);
  let gb = lerp(15, 70, sky.sunIntensity);
  
  for (let y = groundY; y < height; y++) {
    let t = (y - groundY) / (height - groundY);
    fill(gr - t * 5, gg - t * 5, gb - t * 3);
    rect(0, y, width, 1);
  }
  
  // Street line
  if (sky.sunIntensity > 0.2) {
    stroke(gr + 30, gg + 30, gb + 25, 60);
    strokeWeight(1);
    line(0, groundY + (height - groundY) * 0.4, width, groundY + (height - groundY) * 0.4);
    noStroke();
  }
  
  // Street lamps
  let lampOn = sky.sunIntensity < 0.6;
  for (let lx = 60; lx < width; lx += random(150, 250)) {
    let ly = groundY;
    // Pole
    stroke(80, 80, 90);
    strokeWeight(2);
    line(lx, ly, lx, ly - 40);
    noStroke();
    
    // Lamp head
    fill(90, 90, 100);
    rect(lx - 4, ly - 42, 8, 3);
    
    if (lampOn) {
      // Lamp glow
      fill(255, 230, 150, 15);
      ellipse(lx, ly - 20, 80, 60);
      fill(255, 230, 150, 8);
      ellipse(lx, ly - 10, 120, 100);
      // Bulb
      fill(255, 240, 180, 220);
      ellipse(lx, ly - 40, 5, 4);
    }
  }
}

function drawReflections(sky) {
  // Subtle wet-street reflections at night
  if (sky.sunIntensity > 0.5) return;
  
  let groundY = height * 0.85;
  let nightness = 1 - sky.sunIntensity;
  
  // Sample lit windows and draw blurred reflections below
  for (let b of buildings) {
    if (b.layer < 1) continue;
    for (let win of b.windows) {
      if (!win.on) continue;
      let wx = b.x + win.x;
      let wy = groundY - b.h + win.y;
      let reflY = groundY + (groundY - wy) * 0.15;
      
      if (reflY < height) {
        fill(255, 200, 80, nightness * 6);
        ellipse(wx, reflY, win.size * 2, win.size * 0.5);
      }
    }
  }
}

function drawParticles(hour, sky) {
  // Fireflies at dusk/night, birds during day
  let nightness = 1 - sky.sunIntensity;
  let groundY = height * 0.85;
  
  if (nightness > 0.4) {
    // Firefly-like particles
    for (let i = 0; i < 3; i++) {
      if (random() < 0.02) {
        particles.push({
          x: random(width),
          y: random(groundY - 100, groundY),
          vx: random(-0.3, 0.3),
          vy: random(-0.5, 0.1),
          life: random(60, 180),
          maxLife: random(60, 180),
        });
      }
    }
    
    for (let i = particles.length - 1; i >= 0; i--) {
      let p = particles[i];
      p.x += p.vx + sin(frameCount * 0.02 + i) * 0.3;
      p.y += p.vy;
      p.life--;
      
      let alpha = (p.life / p.maxLife) * 200 * nightness;
      fill(255, 240, 150, alpha);
      ellipse(p.x, p.y, 2);
      fill(255, 240, 150, alpha * 0.3);
      ellipse(p.x, p.y, 6);
      
      if (p.life <= 0) particles.splice(i, 1);
    }
  } else {
    particles = [];
  }
}

function draw() {
  let hour = getTimeOfDay();
  
  // Draw sky
  let sky = drawSky(hour);
  
  // Stars
  drawStars(hour, sky);
  
  // Moon
  drawMoon(hour);
  
  // Clouds
  drawClouds(hour, sky);
  
  // Buildings (sorted back to front)
  for (let b of buildings) {
    drawBuilding(b, hour, sky);
  }
  
  // Ground
  drawGround(sky);
  
  // Reflections
  drawReflections(sky);
  
  // Particles
  drawParticles(hour, sky);
  
  // Subtle vignette
  drawVignette();
}

function drawVignette() {
  let cx = width / 2;
  let cy = height / 2;
  let maxD = dist(0, 0, cx, cy);
  
  for (let r = maxD; r > maxD * 0.5; r -= 2) {
    let alpha = map(r, maxD * 0.5, maxD, 0, 60);
    noFill();
    stroke(0, 0, 0, alpha);
    strokeWeight(3);
    ellipse(cx, cy, r * 2);
  }
  noStroke();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  generateCity();
  generateStars();
}
</script>
</body>
</html>
