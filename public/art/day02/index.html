<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ðŸ¦€ GENUARY Day 2 â€” Twelve Principles of Animation</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { overflow: hidden; background: #1a1a2e; width: 100%; height: 100%; }
canvas { display: block; }
#info {
  position: fixed; bottom: 12px; left: 16px;
  font-family: 'Courier New', monospace; font-size: 12px;
  color: rgba(255,255,255,0.2); pointer-events: none; z-index: 10;
}
#principle {
  position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
  font-family: 'Courier New', monospace; font-size: 16px;
  color: rgba(255,255,255,0.5); pointer-events: none; z-index: 10;
  text-align: center; transition: opacity 0.5s;
}
</style>
</head>
<body>
<div id="principle"></div>
<div id="info">GENUARY 2026 Â· Day 2 Â· Twelve Principles of Animation Â· ðŸ¦€ Clawbert</div>
<script>
// â”€â”€ GENUARY Day 2: Twelve Principles of Animation â”€â”€
// A bouncing crab demonstrates all 12 principles in one continuous loop.
//
// 1. Squash & Stretch â€” body deforms on bounce
// 2. Anticipation â€” crouches before big jump
// 3. Staging â€” clear silhouette, spotlight follows
// 4. Straight Ahead / Pose to Pose â€” fluid motion
// 5. Follow Through & Overlapping â€” claws lag behind body
// 6. Slow In / Slow Out â€” eased arcs
// 7. Arc â€” parabolic jump paths
// 8. Secondary Action â€” dust particles, eye blinks
// 9. Timing â€” variable speed for weight
// 10. Exaggeration â€” oversized reactions
// 11. Solid Drawing â€” 3D-ish form with shading
// 12. Appeal â€” cute design, expressive eyes

const PRINCIPLES = [
  "1. Squash & Stretch", "2. Anticipation", "3. Staging",
  "4. Straight Ahead & Pose to Pose", "5. Follow Through & Overlapping Action",
  "6. Slow In & Slow Out", "7. Arc", "8. Secondary Action",
  "9. Timing", "10. Exaggeration", "11. Solid Drawing", "12. Appeal"
];

let t = 0;
let crab;
let particles = [];
let dustClouds = [];
let spotlight;
let currentPrinciple = 0;
let principleTimer = 0;
let stars = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);

  crab = {
    x: width * 0.2,
    y: height * 0.75,
    baseY: height * 0.75,
    vx: 0,
    vy: 0,
    size: min(width, height) * 0.08,
    squashX: 1,
    squashY: 1,
    rotation: 0,
    clawAngleL: 0,
    clawAngleR: 0,
    clawTargetL: 0,
    clawTargetR: 0,
    eyeScale: 1,
    blinkTimer: 0,
    phase: 'idle', // idle, anticipation, jumping, falling, landing, celebrating
    jumpTimer: 0,
    grounded: true,
    facing: 1,
    legPhase: 0,
    expressionMouth: 0, // 0 = neutral, 1 = happy, -1 = focused
  };

  spotlight = { x: crab.x, y: crab.y, targetX: crab.x, targetY: crab.y, radius: crab.size * 5 };

  for (let i = 0; i < 150; i++) {
    stars.push({ x: random(width), y: random(height * 0.6), size: random(1, 3), tw: random(1000) });
  }

  scheduleBounce();
}

function scheduleBounce() {
  crab.phase = 'idle';
  crab.jumpTimer = random(60, 120);
}

function draw() {
  t += deltaTime * 0.001;
  
  // Background â€” deep stage curtain feel (Principle 3: Staging)
  drawBackground();

  // Update principle display
  principleTimer += deltaTime * 0.001;
  if (principleTimer > 3) {
    principleTimer = 0;
    currentPrinciple = (currentPrinciple + 1) % 12;
  }
  let pEl = document.getElementById('principle');
  if (pEl) {
    pEl.textContent = PRINCIPLES[currentPrinciple];
    pEl.style.opacity = (sin(principleTimer / 3 * PI) * 0.5 + 0.5) > 0.1 ? 0.5 : 0;
  }

  // Spotlight follows crab (Principle 3: Staging)
  spotlight.targetX = crab.x;
  spotlight.targetY = crab.y;
  spotlight.x += (spotlight.targetX - spotlight.x) * 0.05;
  spotlight.y += (spotlight.targetY - spotlight.y) * 0.05;
  drawSpotlight();

  // Ground
  drawGround();

  // Update crab
  updateCrab();

  // Dust particles (Principle 8: Secondary Action)
  updateDust();

  // Draw crab
  drawCrab();

  // Floating particles
  updateParticles();
}

function drawBackground() {
  // Gradient stage
  for (let y = 0; y < height * 0.78; y++) {
    let inter = y / (height * 0.78);
    let r = lerp(15, 25, inter);
    let g = lerp(15, 20, inter);
    let b = lerp(35, 40, inter);
    stroke(r, g, b);
    line(0, y, width, y);
  }
  noStroke();

  // Stars
  for (let s of stars) {
    let tw = sin(t * 1.5 + s.tw) * 0.3 + 0.7;
    fill(255, 250, 230, 60 * tw);
    ellipse(s.x, s.y, s.size * tw);
  }
}

function drawSpotlight() {
  // Soft radial gradient spotlight
  let layers = 20;
  for (let i = layers; i > 0; i--) {
    let frac = i / layers;
    let r = spotlight.radius * frac * 3;
    fill(255, 245, 200, 3 * (1 - frac));
    ellipse(spotlight.x, spotlight.y - crab.size, r, r * 0.6);
  }
}

function drawGround() {
  let groundY = crab.baseY + crab.size * 0.35;
  // Stage floor
  fill(30, 25, 45);
  rect(0, groundY, width, height - groundY);

  // Floor shine
  for (let i = 0; i < 5; i++) {
    let alpha = map(i, 0, 5, 15, 0);
    fill(255, 245, 200, alpha);
    let y = groundY + i * 3;
    let w = map(abs(spotlight.x - width / 2), 0, width / 2, width * 0.6, width * 0.2);
    ellipse(spotlight.x, y, w, 6);
  }

  // Shadow under crab (Principle 11: Solid Drawing â€” grounds the character)
  let shadowScale = map(crab.y, crab.baseY - 300, crab.baseY, 0.5, 1.2);
  shadowScale = constrain(shadowScale, 0.3, 1.3);
  let shadowAlpha = map(crab.y, crab.baseY - 300, crab.baseY, 20, 80);
  fill(0, 0, 0, shadowAlpha);
  ellipse(crab.x, groundY + 2, crab.size * 1.8 * shadowScale, crab.size * 0.3 * shadowScale);
}

function updateCrab() {
  let dt = deltaTime * 0.06;

  // Blink timer (Principle 8: Secondary Action)
  crab.blinkTimer -= deltaTime;
  if (crab.blinkTimer <= 0) {
    crab.blinkTimer = random(2000, 5000);
    crab.eyeScale = 0.1; // blink!
  }
  crab.eyeScale += (1 - crab.eyeScale) * 0.15;

  // Claws follow through (Principle 5: Follow Through & Overlapping)
  crab.clawAngleL += (crab.clawTargetL - crab.clawAngleL) * 0.08;
  crab.clawAngleR += (crab.clawTargetR - crab.clawAngleR) * 0.08;

  switch (crab.phase) {
    case 'idle':
      // Gentle breathing
      crab.squashX = 1 + sin(t * 2) * 0.02;
      crab.squashY = 1 - sin(t * 2) * 0.02;
      crab.clawTargetL = sin(t * 1.5) * 0.15;
      crab.clawTargetR = sin(t * 1.5 + 1) * 0.15;
      crab.expressionMouth = 0;

      // Walk slowly
      crab.legPhase += dt * 0.15;
      crab.x += crab.facing * 0.3 * dt;

      // Turn at edges
      if (crab.x > width * 0.85) crab.facing = -1;
      if (crab.x < width * 0.15) crab.facing = 1;

      crab.jumpTimer -= dt;
      if (crab.jumpTimer <= 0) {
        crab.phase = 'anticipation';
        crab.jumpTimer = 25; // frames of anticipation
      }
      break;

    case 'anticipation':
      // Principle 2: Anticipation â€” crouch down before jump
      let antProgress = 1 - (crab.jumpTimer / 25);
      // Principle 10: Exaggeration â€” really squash down
      let easeAnt = antProgress * antProgress; // Principle 6: Slow in
      crab.squashX = 1 + easeAnt * 0.35;
      crab.squashY = 1 - easeAnt * 0.3;
      crab.y = crab.baseY + easeAnt * crab.size * 0.2;
      crab.clawTargetL = -0.5 * easeAnt;
      crab.clawTargetR = -0.5 * easeAnt;
      crab.expressionMouth = -1; // focused

      crab.jumpTimer -= dt;
      if (crab.jumpTimer <= 0) {
        crab.phase = 'jumping';
        // Principle 7: Arc â€” parabolic trajectory
        crab.vy = -random(12, 18);
        crab.vx = crab.facing * random(2, 5);
        // Principle 1: Squash & Stretch â€” stretch on launch
        crab.squashX = 0.7;
        crab.squashY = 1.4;
        crab.clawTargetL = 0.8;
        crab.clawTargetR = 0.8;
        crab.expressionMouth = 1; // happy!

        // Dust on launch
        spawnDust(crab.x, crab.baseY + crab.size * 0.3, 8);
      }
      break;

    case 'jumping':
      // Principle 7: Arc â€” gravity creates parabola
      crab.vy += 0.45 * dt; // gravity
      // Principle 6: Slow in/out â€” natural at arc peak
      crab.x += crab.vx * dt;
      crab.y += crab.vy * dt;

      // Stretch in direction of movement (Principle 1)
      let speed = sqrt(crab.vx * crab.vx + crab.vy * crab.vy);
      let stretchAmt = map(speed, 0, 20, 1, 1.25);
      if (crab.vy < 0) {
        crab.squashX = 1 / stretchAmt;
        crab.squashY = stretchAmt;
      } else {
        // falling
        crab.squashX = stretchAmt * 0.9;
        crab.squashY = 1 / (stretchAmt * 0.9);
        crab.phase = 'falling';
      }

      // Rotation in air (Principle 7: Arc)
      crab.rotation = crab.facing * sin(t * 4) * 0.15;

      // Claws trail behind (Principle 5: Follow Through)
      crab.clawTargetL = 0.6 + crab.vy * 0.03;
      crab.clawTargetR = 0.6 + crab.vy * 0.03;

      // Spawn trail particles
      if (random() < 0.3) {
        particles.push({
          x: crab.x + random(-10, 10), y: crab.y + random(-5, 5),
          vx: random(-0.5, 0.5), vy: random(-0.5, 0.5),
          size: random(2, 5), alpha: 120, life: 1
        });
      }

      if (crab.y >= crab.baseY) {
        crab.y = crab.baseY;
        crab.phase = 'landing';
        crab.jumpTimer = 15;
        // Principle 1: Squash & Stretch â€” squash on impact
        // Principle 10: Exaggeration â€” BIG squash
        crab.squashX = 1.5;
        crab.squashY = 0.5;
        crab.rotation = 0;
        crab.vy = 0;
        crab.vx = 0;
        // Principle 5: Claws overshoot down
        crab.clawTargetL = -0.7;
        crab.clawTargetR = -0.7;
        crab.expressionMouth = 0;

        // Impact dust (Principle 8: Secondary Action)
        spawnDust(crab.x, crab.baseY + crab.size * 0.3, 15);
      }
      break;

    case 'falling':
      crab.vy += 0.45 * dt;
      crab.x += crab.vx * dt;
      crab.y += crab.vy * dt;

      let fallStretch = map(crab.vy, 0, 20, 1, 1.3);
      crab.squashX = 1 / fallStretch;
      crab.squashY = fallStretch;
      crab.rotation *= 0.95;

      crab.clawTargetL = -0.3 + crab.vy * 0.02;
      crab.clawTargetR = -0.3 + crab.vy * 0.02;

      if (crab.y >= crab.baseY) {
        crab.y = crab.baseY;
        crab.phase = 'landing';
        crab.jumpTimer = 15;
        crab.squashX = 1.5;
        crab.squashY = 0.5;
        crab.rotation = 0;
        crab.vy = 0;
        crab.vx = 0;
        crab.clawTargetL = -0.7;
        crab.clawTargetR = -0.7;
        spawnDust(crab.x, crab.baseY + crab.size * 0.3, 15);
      }
      break;

    case 'landing':
      // Principle 9: Timing â€” hold the squash for a beat
      crab.jumpTimer -= dt;
      let landProgress = 1 - (crab.jumpTimer / 15);
      // Principle 6: Slow out â€” ease back to normal
      let easeLand = 1 - pow(1 - landProgress, 3);
      crab.squashX = lerp(1.5, 1, easeLand);
      crab.squashY = lerp(0.5, 1, easeLand);
      crab.y = lerp(crab.baseY + crab.size * 0.15, crab.baseY, easeLand);

      // Principle 5: Claws settle with overshoot
      let overshoot = sin(landProgress * PI * 2) * (1 - landProgress) * 0.3;
      crab.clawTargetL = overshoot;
      crab.clawTargetR = overshoot;

      if (crab.jumpTimer <= 0) {
        // Sometimes celebrate (Principle 12: Appeal)
        if (random() < 0.4) {
          crab.phase = 'celebrating';
          crab.jumpTimer = 60;
          crab.expressionMouth = 1;
        } else {
          scheduleBounce();
        }
      }
      break;

    case 'celebrating':
      // Principle 12: Appeal â€” cute victory dance
      crab.squashX = 1 + sin(t * 8) * 0.08;
      crab.squashY = 1 - sin(t * 8) * 0.08;
      crab.clawTargetL = 0.8 + sin(t * 6) * 0.3;
      crab.clawTargetR = 0.8 + sin(t * 6 + PI) * 0.3;
      crab.rotation = sin(t * 5) * 0.1;
      crab.expressionMouth = 1;

      // Sparkle particles
      if (random() < 0.2) {
        particles.push({
          x: crab.x + random(-crab.size, crab.size),
          y: crab.y - crab.size * 0.5 + random(-crab.size, 0),
          vx: random(-1, 1), vy: random(-2, -0.5),
          size: random(3, 7), alpha: 200, life: 1,
          sparkle: true
        });
      }

      crab.jumpTimer -= deltaTime * 0.06;
      if (crab.jumpTimer <= 0) {
        crab.rotation = 0;
        scheduleBounce();
      }
      break;
  }

  // Keep on stage
  crab.x = constrain(crab.x, width * 0.05, width * 0.95);
}

function drawCrab() {
  push();
  translate(crab.x, crab.y);
  rotate(crab.rotation);
  scale(crab.facing, 1);
  scale(crab.squashX, crab.squashY);

  let s = crab.size;

  // Legs (4 per side) â€” Principle 4: Straight ahead feel
  stroke(180, 60, 50);
  strokeWeight(max(1.5, s * 0.04));
  for (let side = -1; side <= 1; side += 2) {
    for (let i = 0; i < 4; i++) {
      let baseAngle = -0.4 + i * 0.3;
      let legWave = sin(crab.legPhase + i * 1.2 + side * 0.5) * 0.25;
      let angle = baseAngle + legWave;
      let legLen = s * 0.55;
      let midX = cos(angle) * legLen * 0.5;
      let midY = side * (s * 0.25 + abs(sin(crab.legPhase + i)) * 4);
      let endX = cos(angle) * legLen;
      let endY = side * (s * 0.35 + abs(sin(crab.legPhase + i)) * 6);
      line(0, side * s * 0.1, midX, midY);
      line(midX, midY, endX, endY);
    }
  }
  noStroke();

  // Body â€” Principle 11: Solid Drawing (shading for form)
  // Main shell
  fill(200, 70, 55);
  ellipse(0, 0, s, s * 0.75);

  // Shell highlight (3D feel)
  fill(230, 100, 80, 150);
  ellipse(-s * 0.1, -s * 0.1, s * 0.55, s * 0.4);

  // Shell detail line
  fill(170, 55, 45, 100);
  ellipse(s * 0.05, s * 0.05, s * 0.6, s * 0.35);

  // Belly
  fill(230, 130, 100, 80);
  ellipse(0, s * 0.1, s * 0.5, s * 0.25);

  // Eyes â€” Principle 12: Appeal (big expressive eyes)
  let eyeOffX = s * 0.18;
  let eyeOffY = -s * 0.28;
  let eyeSize = s * 0.22;

  // Eye stalks
  fill(200, 70, 55);
  for (let side = -1; side <= 1; side += 2) {
    ellipse(side * eyeOffX, eyeOffY + eyeSize * 0.3, eyeSize * 0.4, eyeSize * 0.6);
  }

  // Eyeballs
  for (let side = -1; side <= 1; side += 2) {
    // White
    fill(255, 250, 240);
    ellipse(side * eyeOffX, eyeOffY, eyeSize, eyeSize * crab.eyeScale);

    if (crab.eyeScale > 0.3) {
      // Iris
      fill(30, 30, 50);
      let pupilSize = eyeSize * 0.5;
      ellipse(side * eyeOffX + crab.facing * 1.5, eyeOffY, pupilSize, pupilSize * crab.eyeScale);

      // Pupil highlight
      fill(255, 255, 255, 200);
      ellipse(side * eyeOffX + crab.facing * 1.5 - 1, eyeOffY - 1.5, pupilSize * 0.35, pupilSize * 0.35 * crab.eyeScale);
    }
  }

  // Mouth â€” Principle 12: Appeal
  noFill();
  stroke(150, 50, 40);
  strokeWeight(1.5);
  if (crab.expressionMouth > 0) {
    // Happy
    arc(0, s * 0.05, s * 0.2, s * 0.15, 0.1, PI - 0.1);
  } else if (crab.expressionMouth < 0) {
    // Focused/determined
    line(-s * 0.06, s * 0.08, s * 0.06, s * 0.06);
  } else {
    // Neutral
    arc(0, s * 0.03, s * 0.12, s * 0.08, 0.2, PI - 0.2);
  }
  noStroke();

  // Claws â€” Principle 5: Follow Through & Overlapping Action
  for (let side = -1; side <= 1; side += 2) {
    push();
    translate(s * 0.4, side * s * 0.15);
    rotate(side * crab[(side === -1) ? 'clawAngleL' : 'clawAngleR']);

    // Arm
    fill(200, 70, 55);
    ellipse(s * 0.15, 0, s * 0.3, s * 0.12);

    // Claw
    fill(220, 85, 65);
    push();
    translate(s * 0.3, 0);
    // Top pincer
    let pincerOpen = 0.2 + sin(t * 3 + side) * 0.1;
    push();
    rotate(-pincerOpen);
    ellipse(s * 0.08, -s * 0.02, s * 0.22, s * 0.09);
    pop();
    // Bottom pincer
    push();
    rotate(pincerOpen);
    ellipse(s * 0.08, s * 0.02, s * 0.22, s * 0.09);
    pop();
    pop();
    pop();
  }

  pop();
}

function spawnDust(x, y, count) {
  for (let i = 0; i < count; i++) {
    dustClouds.push({
      x: x + random(-15, 15),
      y: y + random(-5, 5),
      vx: random(-3, 3),
      vy: random(-3, -0.5),
      size: random(5, 15),
      alpha: random(100, 180),
      life: 1
    });
  }
}

function updateDust() {
  for (let i = dustClouds.length - 1; i >= 0; i--) {
    let d = dustClouds[i];
    d.x += d.vx * 0.5;
    d.y += d.vy * 0.3;
    d.vy += 0.02;
    d.life -= 0.015;
    d.size *= 1.01;
    if (d.life <= 0) { dustClouds.splice(i, 1); continue; }
    fill(180, 160, 140, d.alpha * d.life);
    ellipse(d.x, d.y, d.size);
  }
  if (dustClouds.length > 100) dustClouds.splice(0, dustClouds.length - 100);
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 0.01;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    if (p.sparkle) {
      let sparkle = sin(t * 10 + p.x) * 0.5 + 0.5;
      fill(255, 230, 150, p.alpha * p.life * sparkle);
      let sz = p.size * p.life;
      // Star shape
      push();
      translate(p.x, p.y);
      rotate(t * 3 + p.x);
      for (let a = 0; a < 4; a++) {
        rotate(HALF_PI);
        ellipse(0, 0, sz * 0.3, sz);
      }
      pop();
    } else {
      fill(200, 180, 160, p.alpha * p.life);
      ellipse(p.x, p.y, p.size * p.life);
    }
  }
  if (particles.length > 80) particles.splice(0, particles.length - 80);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  crab.baseY = height * 0.75;
  crab.size = min(width, height) * 0.08;
  stars = [];
  for (let i = 0; i < 150; i++) {
    stars.push({ x: random(width), y: random(height * 0.6), size: random(1, 3), tw: random(1000) });
  }
}
</script>
</body>
</html>
