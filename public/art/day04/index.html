<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ðŸ¦€ GENUARY Day 4 â€” Lowres</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { overflow: hidden; background: #1a1a2e; width: 100%; height: 100%; }
canvas { display: block; image-rendering: pixelated; }
#info {
  position: fixed; bottom: 8px; left: 12px;
  font-family: 'Courier New', monospace; font-size: 11px;
  color: rgba(255,255,255,0.15); pointer-events: none; z-index: 10;
}
</style>
</head>
<body>
<div id="info">GENUARY 2026 Â· Day 4 Â· Lowres Â· ðŸ¦€ Clawbert</div>
<script>
// â”€â”€ GENUARY Day 4: Lowres â”€â”€
// Tidepools, but as if it ran on a Game Boy.
// Everything rendered to a tiny buffer (64x64) then scaled up.
// Pixel crabs, chunky waves, lo-fi ocean vibes.

const RES = 72; // Tiny resolution
let buf; // Low-res buffer
let t = 0;
let crabs = [];
let bubbles = [];
let shells = [];
let fish = [];

// 8-bit color palette (limited like a real retro console)
const PAL = {
  sky1:     [15, 20, 45],
  sky2:     [25, 40, 75],
  sky3:     [45, 70, 110],
  ocean1:   [12, 30, 65],
  ocean2:   [20, 50, 90],
  ocean3:   [30, 70, 115],
  wave:     [55, 100, 145],
  foam:     [140, 180, 200],
  sand1:    [160, 130, 80],
  sand2:    [140, 110, 65],
  sand3:    [120, 95, 55],
  crab1:    [180, 55, 40],
  crab2:    [210, 80, 55],
  crabEye:  [240, 240, 220],
  shell1:   [200, 160, 110],
  shell2:   [170, 130, 90],
  kelp1:    [25, 80, 40],
  kelp2:    [40, 110, 55],
  star:     [200, 200, 170],
  moon:     [220, 225, 210],
  fish1:    [200, 150, 50],
  fish2:    [50, 150, 200],
  bubble:   [120, 170, 210],
};

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  noSmooth(); // Keep it crunchy!
  
  // Create low-res buffer
  buf = createGraphics(RES, RES);
  buf.pixelDensity(1);
  buf.noSmooth();
  
  // Pixel crabs
  for (let i = 0; i < 3; i++) {
    crabs.push({
      x: random(5, RES - 5),
      y: random(RES * 0.78, RES * 0.88),
      dir: random() > 0.5 ? 1 : -1,
      speed: random(0.01, 0.03),
      legFrame: 0,
      pauseTimer: random(0, 200),
      size: floor(random(3, 5))
    });
  }
  
  // Pixel shells
  for (let i = 0; i < 4; i++) {
    shells.push({
      x: floor(random(3, RES - 3)),
      y: floor(random(RES * 0.8, RES * 0.92)),
      type: floor(random(3))
    });
  }
  
  // Pixel fish
  for (let i = 0; i < 2; i++) {
    fish.push({
      x: random(RES),
      y: random(RES * 0.45, RES * 0.7),
      dir: random() > 0.5 ? 1 : -1,
      speed: random(0.02, 0.06),
      color: random() > 0.5 ? PAL.fish1 : PAL.fish2,
      tailFrame: 0
    });
  }
}

function draw() {
  t += deltaTime * 0.001;
  
  // Draw everything to the tiny buffer
  buf.noStroke();
  drawLowRes();
  
  // Scale up to fill screen (pixelated!)
  let scale = min(width / RES, height / RES);
  let offX = (width - RES * scale) / 2;
  let offY = (height - RES * scale) / 2;
  
  background(0);
  // Black bars
  noStroke();
  
  // Draw scaled buffer
  image(buf, offX, offY, RES * scale, RES * scale);
}

function drawLowRes() {
  let b = buf;
  let daylight = getDaylight();
  
  // â”€â”€ Sky â”€â”€
  let skyH = floor(RES * 0.4);
  for (let y = 0; y < skyH; y++) {
    let frac = y / skyH;
    let c = lerpPal(PAL.sky1, PAL.sky3, frac, daylight);
    b.fill(c[0], c[1], c[2]);
    b.rect(0, y, RES, 1);
  }
  
  // Stars (night only)
  if (daylight < 0.6) {
    let starAlpha = map(daylight, 0, 0.6, 255, 0);
    b.fill(PAL.star[0], PAL.star[1], PAL.star[2], starAlpha);
    let starPositions = [[5,3],[15,7],[28,2],[40,8],[55,4],[65,6],[10,15],[48,12],[33,5],[60,10]];
    for (let sp of starPositions) {
      if (sin(t * 2 + sp[0]) > -0.3) {
        b.rect(sp[0] % RES, sp[1], 1, 1);
      }
    }
    
    // Moon
    let moonAlpha = map(daylight, 0, 0.5, 220, 0);
    b.fill(PAL.moon[0], PAL.moon[1], PAL.moon[2], moonAlpha);
    b.rect(RES - 12, 4, 3, 3);
    b.rect(RES - 11, 3, 2, 5);
    b.rect(RES - 13, 5, 1, 1);
    // Crescent shadow
    b.fill(PAL.sky1[0], PAL.sky1[1], PAL.sky1[2], moonAlpha * 0.8);
    b.rect(RES - 11, 3, 2, 3);
  }
  
  // â”€â”€ Ocean â”€â”€
  let oceanTop = skyH;
  let sandTop = floor(RES * 0.75);
  
  for (let y = oceanTop; y < sandTop; y++) {
    let frac = (y - oceanTop) / (sandTop - oceanTop);
    let c = lerpPal(PAL.ocean3, PAL.ocean1, frac, daylight);
    b.fill(c[0], c[1], c[2]);
    b.rect(0, y, RES, 1);
  }
  
  // Wave lines
  for (let w = 0; w < 3; w++) {
    let waveY = oceanTop + w * 4 + 1;
    let c = w === 0 ? PAL.foam : PAL.wave;
    let alpha = w === 0 ? 150 : 80;
    b.fill(c[0], c[1], c[2], alpha * (0.3 + daylight * 0.7));
    for (let x = 0; x < RES; x++) {
      let offset = floor(sin(x * 0.3 + t * (1.5 - w * 0.3) + w * 2) * 1.5);
      b.rect(x, waveY + offset, 1, 1);
    }
  }
  
  // â”€â”€ Kelp â”€â”€
  let kelpPositions = [8, 22, 45, 58, 67];
  for (let kx of kelpPositions) {
    let baseY = sandTop - 1;
    let segments = floor(random(4, 7));
    for (let s = 0; s < segments; s++) {
      let sway = floor(sin(t * 1.2 + kx + s * 0.5) * 1.5);
      let px = kx + sway;
      let py = baseY - s * 2;
      if (py < oceanTop) break;
      let c = s % 2 === 0 ? PAL.kelp1 : PAL.kelp2;
      let bright = 0.4 + daylight * 0.6;
      b.fill(c[0] * bright, c[1] * bright, c[2] * bright);
      b.rect(px, py, 2, 2);
    }
  }
  
  // â”€â”€ Fish â”€â”€
  for (let f of fish) {
    f.x += f.dir * f.speed * deltaTime * 0.06;
    f.tailFrame += deltaTime * 0.005;
    if (f.x > RES + 5) { f.x = -4; f.dir = 1; }
    if (f.x < -5) { f.x = RES + 4; f.dir = -1; }
    
    let fx = floor(f.x);
    let fy = floor(f.y);
    let bright = 0.4 + daylight * 0.6;
    
    // Body (3 pixels)
    b.fill(f.color[0] * bright, f.color[1] * bright, f.color[2] * bright);
    b.rect(fx, fy, 3, 1);
    b.rect(fx + (f.dir > 0 ? 0 : 2), fy - 1, 1, 1); // top fin pixel
    
    // Tail (wiggles)
    let tailOff = floor(sin(f.tailFrame * 3) * 1);
    let tailX = f.dir > 0 ? fx - 1 : fx + 3;
    b.rect(tailX, fy + tailOff, 1, 1);
    
    // Eye
    b.fill(PAL.crabEye[0], PAL.crabEye[1], PAL.crabEye[2]);
    let eyeX = f.dir > 0 ? fx + 2 : fx;
    b.rect(eyeX, fy, 1, 1);
  }
  
  // â”€â”€ Bubbles â”€â”€
  if (random() < 0.03) {
    bubbles.push({ x: floor(random(RES)), y: floor(RES * 0.7), life: 1 });
  }
  b.fill(PAL.bubble[0], PAL.bubble[1], PAL.bubble[2], 120 * (0.3 + daylight * 0.7));
  for (let i = bubbles.length - 1; i >= 0; i--) {
    let bb = bubbles[i];
    bb.y -= 0.02 * deltaTime * 0.06;
    bb.x += sin(t * 3 + bb.x) * 0.02;
    bb.life -= 0.001 * deltaTime * 0.06;
    if (bb.y < oceanTop || bb.life <= 0) { bubbles.splice(i, 1); continue; }
    b.rect(floor(bb.x), floor(bb.y), 1, 1);
  }
  
  // â”€â”€ Sand â”€â”€
  for (let y = sandTop; y < RES; y++) {
    let frac = (y - sandTop) / (RES - sandTop);
    let c = lerpPal(PAL.sand1, PAL.sand3, frac, daylight);
    b.fill(c[0], c[1], c[2]);
    b.rect(0, y, RES, 1);
  }
  
  // Sand ripple lines
  b.fill(PAL.sand1[0] + 15, PAL.sand1[1] + 10, PAL.sand1[2] + 5, 40 * (0.3 + daylight * 0.7));
  for (let r = 0; r < 3; r++) {
    let ry = sandTop + 3 + r * 5;
    for (let x = 0; x < RES; x += 3) {
      let offset = floor(sin(x * 0.2 + r + t * 0.2) * 0.8);
      b.rect(x, ry + offset, 2, 1);
    }
  }
  
  // â”€â”€ Shells â”€â”€
  for (let s of shells) {
    let bright = 0.5 + daylight * 0.5;
    let c = s.type === 0 ? PAL.shell1 : PAL.shell2;
    b.fill(c[0] * bright, c[1] * bright, c[2] * bright);
    if (s.type === 0) {
      // Spiral shell (3x3)
      b.rect(s.x, s.y, 2, 2);
      b.rect(s.x + 2, s.y + 1, 1, 1);
    } else if (s.type === 1) {
      // Conch (3x2)
      b.rect(s.x, s.y, 3, 1);
      b.rect(s.x + 1, s.y + 1, 1, 1);
    } else {
      // Star shell
      b.rect(s.x + 1, s.y, 1, 1);
      b.rect(s.x, s.y + 1, 3, 1);
      b.rect(s.x + 1, s.y + 2, 1, 1);
    }
  }
  
  // â”€â”€ Crabs â”€â”€
  for (let c of crabs) {
    c.pauseTimer -= deltaTime;
    if (c.pauseTimer <= 0) {
      c.x += c.dir * c.speed * deltaTime * 0.06;
      c.legFrame += deltaTime * 0.008;
      if (c.pauseTimer < -random(2000, 5000)) {
        c.pauseTimer = random(1000, 3000);
        if (random() < 0.4) c.dir *= -1;
      }
    }
    if (c.x > RES - 2) c.dir = -1;
    if (c.x < 2) c.dir = 1;
    
    drawPixelCrab(b, floor(c.x), floor(c.y), c.dir, c.legFrame, c.size, daylight);
  }
  
  // Shore foam animation
  let foamX = floor(sin(t * 0.5) * 8 + RES * 0.5);
  let foamY = sandTop - 1;
  b.fill(PAL.foam[0], PAL.foam[1], PAL.foam[2], 60 * (0.3 + daylight * 0.7));
  for (let x = foamX - 15; x < foamX + 15; x++) {
    if (x < 0 || x >= RES) continue;
    let show = sin(x * 0.5 + t * 2) > 0.2;
    if (show) b.rect(x, foamY + floor(sin(x * 0.3 + t) * 0.8), 1, 1);
  }
}

function drawPixelCrab(b, x, y, dir, legFrame, size, daylight) {
  let bright = 0.5 + daylight * 0.5;
  let c1 = [PAL.crab1[0] * bright, PAL.crab1[1] * bright, PAL.crab1[2] * bright];
  let c2 = [PAL.crab2[0] * bright, PAL.crab2[1] * bright, PAL.crab2[2] * bright];
  
  if (size >= 4) {
    // Big crab (5x3 body)
    // Body
    b.fill(c1[0], c1[1], c1[2]);
    b.rect(x - 2, y, 5, 2);
    b.rect(x - 1, y - 1, 3, 1);
    
    // Shell highlight
    b.fill(c2[0], c2[1], c2[2]);
    b.rect(x - 1, y, 3, 1);
    
    // Eyes
    b.fill(PAL.crabEye[0], PAL.crabEye[1], PAL.crabEye[2]);
    b.rect(x - 1, y - 2, 1, 1);
    b.rect(x + 1, y - 2, 1, 1);
    
    // Claws
    b.fill(c1[0], c1[1], c1[2]);
    let clawOpen = sin(t * 3 + x) > 0 ? 1 : 0;
    // Left claw
    b.rect(x - 3, y - 1, 1, 1);
    b.rect(x - 3 - clawOpen, y - 2, 1, 1);
    // Right claw
    b.rect(x + 3, y - 1, 1, 1);
    b.rect(x + 3 + clawOpen, y - 2, 1, 1);
    
    // Legs (animated)
    let legOff = floor(sin(legFrame * 3)) ;
    b.rect(x - 2, y + 2, 1, 1);
    b.rect(x, y + 2 + legOff, 1, 1);
    b.rect(x + 2, y + 2, 1, 1);
  } else {
    // Small crab (3x2)
    b.fill(c1[0], c1[1], c1[2]);
    b.rect(x - 1, y, 3, 1);
    b.rect(x, y - 1, 1, 1);
    
    // Eyes
    b.fill(PAL.crabEye[0], PAL.crabEye[1], PAL.crabEye[2]);
    b.rect(x - 1, y - 1, 1, 1);
    b.rect(x + 1, y - 1, 1, 1);
    
    // Legs
    let legOff = floor(sin(legFrame * 3));
    b.rect(x - 1, y + 1 + legOff, 1, 1);
    b.rect(x + 1, y + 1, 1, 1);
  }
}

function getDaylight() {
  let h = hour() + minute() / 60;
  if (h < 5) return 0;
  if (h < 7) return map(h, 5, 7, 0, 1);
  if (h < 17) return 1;
  if (h < 20) return map(h, 17, 20, 1, 0);
  return 0;
}

function lerpPal(c1, c2, frac, daylight) {
  let bright = 0.35 + daylight * 0.65;
  return [
    lerp(c1[0], c2[0], frac) * bright,
    lerp(c1[1], c2[1], frac) * bright,
    lerp(c1[2], c2[2], frac) * bright
  ];
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
